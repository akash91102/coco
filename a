import React, { Component, Fragment } from 'react';
import autoBind from 'react-autobind';
import { bindActionCreators } from 'redux';
import { connect } from 'react-redux';
import { fetchConfig } from './config/config';
import axios from 'axios';
import moment from 'moment';

import {
    configSetup,
    formBind,
    newFormBind,
    tableEntryUpdate,
    tableOnlySetup
} from '../../../../../../javascript/config';

import {
    cloneObject,
    Debouncer,
    objectExists,
    traverseFormToBindValue,
    traverseObject,
    traverseObjectAndInsert,
    traverseObjectAndReturn,
    updateObjectWithMatchingKeys
} from '../../../../../../javascript/utility';

import {
    mixinCheckGlobalConditions,
    mixinIsFormValid,
    mixinToggleModal
} from '../../../../../../javascript/mixins';

import { DataGrid } from '@jpmuitk/data-grid';
import { Button, Dialog, DialogActions, DialogContent, Icon, Spinner } from '@jpmuitk/components';

import Buttons from '../../../../../Common/Buttons/Buttons';
import Header from '../../../../../Common/Header/Header';
import FormBuilder from '../../../../../Common/FormBuilder';
import AmountGrid from '../../../../../Common/Amount/AmountGrid';
import EligibleProducts from '../../../../../Common/EligibleProduct/EligibleProducts';

import * as appStateAction from '../../../../../../actions/appStateAction';
import configRest from '../../../../../../config/config';
import { dropdownPresets } from '../../../../../../config/dropdownPresets';
import { isReadWrite } from '../../../../../../javascript/entitlementUtils';
import { inlineGetServiceCall } from '../../../../../../api/ApiUtils';
import { MessageBox } from '../../../../../Common/messagebox';

const debounce = new Debouncer();
const key = 'profileFields';
let filteredData = null;
let selectedRowIdx = null;

class ProfileFields extends Component {
    constructor(props) {
        super(props);

        this.state = {
            permissions: {
                readonly: this.props.data.profileReadOnly ? true : !isReadWrite(this.props.userInfo, 'ROLE_AGENCY_UI_READ_WRITE'),
                partialReadonly: this.props.data.profileReadOnly ? true : !isReadWrite(this.props.userInfo, 'ROLE_AGENCY_UI_READ_WRITE')
            },
            config: null,
            toggleState: true,
            ready: true,
            gridApi: {},
            modal: {
                disabled: null,
                show: false,
                header: {},
                formdata: null,
                onUpdate: () => {},
                onSave: () => {}
            },
            resetFormFields: {
                resetIfSelected: [{ field: 'frequency', value: '*' }],
                resetExclude: ['frequency']
            }
        };

        // Event bindings for form interactions
        this.bindedEvents = {
            // Profile Information Events
            HANDLE_PROFILE_STATUS_UPDATE: (status) => {
                this.updateProfileField('profileStatus', status);
            },

            HANDLE_AGREEMENT_UPDATE: (agreementData) => {
                this.updateAgreementData(agreementData);
            },

            // Cross Product Margin Calc Events
            HANDLE_TIER_UPDATE: (tierData) => {
                this.updateTierConfiguration(tierData);
            },

            HANDLE_ADD_ON_TOGGLE: (addOnType, value) => {
                this.updateAddOnConfiguration(addOnType, value);
            },

            HANDLE_HOUSE_MULTIPLIER_UPDATE: (multiplier) => {
                this.updateHouseMultiplier(multiplier);
            },

            // Master Agreements Events
            CREATE_NEW_MASTER_AGREEMENT: () => {
                this.createNewMasterAgreement();
            },

            EDIT_MASTER_AGREEMENT: (agreementId) => {
                this.editMasterAgreement(agreementId);
            },

            DELETE_MASTER_AGREEMENT: (agreementId) => {
                this.deleteMasterAgreement(agreementId);
            },

            // Product Setup Events
            HANDLE_PRODUCT_SETUP_UPDATE: (setupData) => {
                this.updateProductSetup(setupData);
            },

            // Validation Events
            VALIDATE_PROFILE_DATA: () => {
                return this.validateProfileData();
            },

            // Conditional Rendering Events
            IS_PROFILE_EDITABLE: () => {
                return this.isProfileEditable();
            },

            IS_AGREEMENT_ACTIVE: () => {
                return this.isAgreementActive();
            },

            // Tab Navigation Events
            HANDLE_TAB_CHANGE: (tabId) => {
                this.handleTabChange(tabId);
            }
        };

        autoBind(this);

        // Button configuration
        this.buttons = this.state.permissions.readonly ? 
            [{ title: 'Cancel', onclick: this.props.onCancel }] : 
            [
                { title: 'Cancel', onclick: this.props.onCancel },
                { title: 'Save Draft', onclick: this.props.onSave, displayIf: this.isProfileNewOrActive.bind(this) },
                { title: 'Submit', onclick: this.props.onSubmit, displayIf: this.isProfileNewOrActive.bind(this) },
                { title: 'Deactivate', onclick: this.props.onDeactivate, displayIf: this.isProfileActive.bind(this) },
                { title: 'Activate', onclick: this.props.onActivate, displayIf: this.isProfileInactive.bind(this) }
            ];
    }

    // Profile status check methods
    isProfileNewOrActive() {
        const profilePresent = objectExists(this, 'props.data.profileInformation.status');
        return !profilePresent || this.props.data.profileInformation.status === 'Live' || this.props.data.profileInformation.status === 'New';
    }

    isProfileActive() {
        const profilePresent = objectExists(this, 'props.data.profileInformation.status');
        return profilePresent && this.props.data.profileInformation.status === 'Live';
    }

    isProfileInactive() {
        const profilePresent = objectExists(this, 'props.data.profileInformation.status');
        return profilePresent && this.props.data.profileInformation.status === 'Inactive';
    }

    // Component lifecycle
    componentDidMount() {
        this.setup(fetchConfig(this.props.appState.lob));
    }

    // Main setup method
    setup = (config) => {
        let cloneData = cloneObject(this.props.data);
        
        // Initialize profile data structure if needed
        this.initializeProfileData(cloneData);
        
        // Setup configuration
        let configSetupVar = configSetup({
            config,
            formdata: cloneData,
            staticData: this.props.staticData,
            bindFunctions: this.bindedEvents
        });
        
        this.setState({ config: configSetupVar });
        this.props.onCustFormUpdate(cloneData);
    };

    // Initialize profile data structure
    initializeProfileData = (data) => {
        // Ensure profile information structure exists
        if (!data.profileInformation) {
            data.profileInformation = {
                profileId: '',
                agreementNo: '',
                agreementType: '',
                status: 'New',
                updatedBy: '',
                updatedAt: moment().format('YYYY-MM-DD HH:mm:ss.SSS')
            };
        }

        // Ensure cross product margin calc structure exists
        if (!data.crossProductMarginCalc) {
            data.crossProductMarginCalc = {
                tier: 1,
                tierVersion: '',
                tierEffectiveDate: '',
                addOns: {
                    liquidity: false,
                    tenor: false,
                    fxPair: false
                },
                houseMultiplier: 1
            };
        }

        // Ensure in scope master agreements structure exists
        if (!data.inScopeMasterAgreements) {
            data.inScopeMasterAgreements = [];
        }

        // Ensure product setup structure exists
        if (!data.productSetup) {
            data.productSetup = {
                isActive: false,
                highlightColor: '#9966ff'
            };
        }
    };

    // Profile field update methods
    updateProfileField = (fieldName, value) => {
        let clone = cloneObject(this.state.config);
        let formData = cloneObject(this.props.data);

        // Update the specific field
        if (formData.profileInformation) {
            formData.profileInformation[fieldName] = value;
            formData.profileInformation.updatedAt = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        }

        this.updateFormAndData(clone, formData);
    };

    updateAgreementData = (agreementData) => {
        let formData = cloneObject(this.props.data);
        
        // Update agreement information
        Object.assign(formData.profileInformation, agreementData);
        formData.profileInformation.updatedAt = moment().format('YYYY-MM-DD HH:mm:ss.SSS');

        this.props.onCustFormUpdate(formData);
    };

    updateTierConfiguration = (tierData) => {
        let formData = cloneObject(this.props.data);
        
        // Update tier configuration
        Object.assign(formData.crossProductMarginCalc, tierData);
        
        this.props.onCustFormUpdate(formData);
    };

    updateAddOnConfiguration = (addOnType, value) => {
        let formData = cloneObject(this.props.data);
        
        // Update add-on configuration
        if (formData.crossProductMarginCalc && formData.crossProductMarginCalc.addOns) {
            formData.crossProductMarginCalc.addOns[addOnType] = value;
        }
        
        this.props.onCustFormUpdate(formData);
    };

    updateHouseMultiplier = (multiplier) => {
        let formData = cloneObject(this.props.data);
        
        // Update house multiplier
        if (formData.crossProductMarginCalc) {
            formData.crossProductMarginCalc.houseMultiplier = multiplier;
        }
        
        this.props.onCustFormUpdate(formData);
    };

    updateProductSetup = (setupData) => {
        let formData = cloneObject(this.props.data);
        
        // Update product setup
        Object.assign(formData.productSetup, setupData);
        
        this.props.onCustFormUpdate(formData);
    };

    // Master agreement management
    createNewMasterAgreement = () => {
        const { data, onTableUpdate } = this.props;
        let newEntry = null;
        const prop = 'inScopeMasterAgreements';

        selectedRowIdx = null;

        this.toggleModal({
            state: true,
            header: { title: 'Create New Master Agreement' },
            formdata: newFormBind({ formdata: this.state.config.create.newMasterAgreement }),
            onUpdate: (newdata) => {
                newEntry = tableEntryUpdate({ newdata, markSource: true });
            },
            onSave: () => {
                let exists = false;
                let formData = cloneObject(data);
                
                if (!formData.inScopeMasterAgreements) {
                    formData.inScopeMasterAgreements = [];
                }

                // Check for duplicates
                formData.inScopeMasterAgreements.forEach(item => {
                    if (item.agreementNumber === newEntry.agreementNumber) {
                        exists = true;
                        MessageBox.error('Validation Error', 'Agreement number already exists.', 500);
                    }
                });

                if (!exists) {
                    formData.inScopeMasterAgreements.push(newEntry);
                    this.toggleModal(false);
                    this.props.onCustFormUpdate(formData);
                    this.gridBindEvents(this.state.gridApi["inScopeMasterAgreements"]);
                }
            }
        });
    };

    editMasterAgreement = (agreementId) => {
        // Implementation for editing master agreement
        console.log('Editing master agreement:', agreementId);
    };

    deleteMasterAgreement = (agreementId) => {
        // Implementation for deleting master agreement
        console.log('Deleting master agreement:', agreementId);
    };

    // Tab navigation
    handleTabChange = (tabId) => {
        // Update active tab state
        this.setState({ activeTab: tabId });
        
        // Trigger any tab-specific logic
        if (this.props.onTabChange) {
            this.props.onTabChange(tabId);
        }
    };

    // Validation methods
    validateProfileData = () => {
        const { data } = this.props;
        let isValid = true;
        let errors = [];

        // Validate required profile information
        if (!data.profileInformation?.profileId) {
            errors.push('Profile ID is required');
            isValid = false;
        }

        if (!data.profileInformation?.agreementNo) {
            errors.push('Agreement Number is required');
            isValid = false;
        }

        // Add more validation rules as needed

        if (!isValid) {
            MessageBox.error('Validation Error', errors.join('\n'), 500);
        }

        return isValid;
    };

    isProfileEditable = () => {
        return !this.state.permissions.readonly && this.isProfileNewOrActive();
    };

    isAgreementActive = () => {
        const agreement = this.props.data.profileInformation;
        return agreement && agreement.status === 'Live';
    };

    // Grid event handlers
    onGridReady = ({ e, refKey }) => {
        const { gridApi } = this.state;
        const { api } = e;

        gridApi[refKey] = api;

        this.setState({ gridApi }, () => {
            api.sizeColumnsToFit();
            this.gridBindEvents({ api: gridApi[refKey] });
        });
    };

    gridBindEvents = ({ api }) => {
        // Bind grid events for master agreements table
        setTimeout(() => {
            document.querySelectorAll('.masterAgreementRemoveBtn').forEach((ele, index) => {
                ele.classList.remove("masterAgreementRemoveBtn");
                
                ele.addEventListener("click", () => {
                    const { gridApi } = this.state;
                    let rowData = [];
                    const gridApi_ma = gridApi['inScopeMasterAgreements'];

                    gridApi_ma.forEachNode((rowNode, i) => {
                        if (i !== index) {
                            rowData.push(rowNode.data);
                        }
                    });
                    
                    gridApi_ma.setRowData(rowData);

                    // Update data
                    let formData = cloneObject(this.props.data);
                    formData.inScopeMasterAgreements.splice(index, 1);
                    this.props.onCustFormUpdate(formData);

                    // Rebind buttons
                    this.gridBindEvents({ api: gridApi_ma });
                });
            });
        });
    };

    onCellClicked = ({ e, createKey = null, markSource = null, bind, refKey }) => {
        let { colDef, rowIndex } = e;
        const { actions = null, renderAsLink = null, cellRenderer } = colDef;
        selectedRowIdx = rowIndex;

        if (cellRenderer === 'removeItem') return;

        if ((actions === null && renderAsLink === null) && !!createKey) {
            // Handle cell click for editing
            const { data } = this.props;
            let currentEntry;
            let prop = bind;

            let obj = !!data ? cloneObject(data) : {};
            let arr = traverseObjectAndReturn({ obj, string: prop });

            const formdata = formBind({
                formdata: this.state.config.create[createKey],
                data: arr[rowIndex],
                staticData: this.props.staticData
            });

            this.toggleModal({
                state: true,
                header: { title: 'Edit' },
                formdata,
                onUpdate: (newdata) => {
                    currentEntry = tableEntryUpdate({ newdata, markSource });
                },
                onSave: () => {
                    // Update the specific row
                    updateObjectWithMatchingKeys({ obj: arr[rowIndex], data: currentEntry });
                    this.props.onCustFormUpdate(data);
                    this.gridBindEvents({ api: this.state.gridApi[refKey] });
                    this.toggleModal(false);
                }
            });
        }
    };

    // Helper methods
    updateFormAndData = (config, formData) => {
        this.props.onFormUpdate(config);
        this.props.onCustFormUpdate(formData);
        
        this.setState({ config, ready: false }, () => {
            this.setState({ ready: true });
        });
    };

    // Mixin methods
    isFormValid = (props) => {
        mixinIsFormValid({ ...props, _this: this });
    };

    toggleModal = (props) => {
        mixinToggleModal({ ...props, _this: this });
    };

    checkGlobalConditions = (renderIf = null) => {
        return mixinCheckGlobalConditions({ renderIf, _this: this });
    };

    render() {
        const { 
            buttons, 
            bindedEvents, 
            checkGlobalConditions, 
            toggleModal, 
            onGridReady, 
            onCellClicked, 
            isFormValid 
        } = this;
        
        const { ready, modal, config, permissions } = this.state;
        const { onFormUpdate, onCustFormUpdate, staticData } = this.props;
        let formData = this.props.data;

        return !!config && ready ? (
            <div style={{ marginTop: '10px', marginBottom: '10px' }}>
                {/* Loop through JSON config layout */}
                {config.layout.map((x, i) => {
                    const { 
                        refKey, 
                        createKey, 
                        header, 
                        type, 
                        data, 
                        columnDefs, 
                        renderIf, 
                        markSource, 
                        bind, 
                        rowClassRules 
                    } = x;

                    return checkGlobalConditions(renderIf) ? (
                        <div 
                            className={
                                !!type && (type === 'amount' || type === 'eligibleProduct') 
                                    ? 'rating-container' 
                                    : 'dt-container'
                            } 
                            key={i}
                        >
                            {!!header ? (
                                <Header 
                                    {...header} 
                                    bindedEvents={bindedEvents} 
                                    permissions={permissions} 
                                />
                            ) : null}

                            {!!type && type === 'form' ? (
                                <FormBuilder 
                                    data={data} 
                                    onFormUpdate={onFormUpdate} 
                                    bindedEvents={bindedEvents} 
                                    permissions={permissions} 
                                    staticData={staticData} 
                                />
                            ) : null}

                            {!!type && type === 'datatable' ? (
                                <DataGrid
                                    suppressRowClickSelection={true}
                                    containerProps={{ style: { height: '200px' } }}
                                    rowStripes
                                    columnDefs={columnDefs}
                                    rowClassRules={rowClassRules}
                                    rowData={traverseFormToBindValue({ formData, bind })}
                                    onCellClicked={e => { onCellClicked({ e, createKey, markSource, refKey, bind }) }}
                                    onGridReady={(e) => { onGridReady({ e, refKey }) }}
                                    refKey={refKey}
                                />
                            ) : null}

                            {!!type && type === 'amount' ? (
                                <AmountGrid
                                    rowClassRules={rowClassRules}
                                    bind={bind}
                                    formData={formData}
                                    onCustFormUpdate={onCustFormUpdate}
                                    config={this.state.config}
                                    readonly={permissions.readonly}
                                    isMultiCurrencyEnabled={true}
                                    optionCurrency={dropdownPresets.CURRENCY}
                                    refKey={refKey}
                                />
                            ) : null}

                            {!!type && type === 'eligibleProduct' ? (
                                <EligibleProducts
                                    bind={bind}
                                    formData={formData}
                                    onCustFormUpdate={onCustFormUpdate}
                                    bindedEvents={bindedEvents}
                                    config={this.state.config}
                                    refKey={refKey}
                                />
                            ) : null}
                        </div>
                    ) : null;
                })}

                {/* Modal for adding/editing entries */}
                <Dialog
                    onEntered={() => {}}
                    open={modal.show}
                    onClick={() => {}}
                    onClose={() => { toggleModal(false) }}
                >
                    <div>
                        {!!modal.show ? (
                            <DialogContent>
                                <div className='dt-container'>
                                    <Header {...modal.header} permissions={permissions} />
                                    <FormBuilder 
                                        data={this.state.modal.formdata.data} 
                                        onFormUpdate={modal.onUpdate} 
                                        isFormValid={isFormValid} 
                                        permissions={permissions} 
                                        staticData={staticData} 
                                    />
                                </div>
                            </DialogContent>
                        ) : null}

                        <DialogActions>
                            {!permissions.readonly ? (
                                <Button 
                                    variant={'cta'} 
                                    disabled={modal.disabled} 
                                    onClick={modal.onSave}
                                >
                                    Save
                                </Button>
                            ) : null}
                            <Button 
                                variant={'cta'} 
                                onClick={() => { toggleModal(false) }}
                            >
                                Close
                            </Button>
                        </DialogActions>
                    </div>
                </Dialog>

                <Buttons data={buttons} />
            </div>
        ) : null;
    }
}

// Redux connection
const mapStateToProps = state => {
    const { appState } = state;
    return { appState };
};

const mapDispatchToProps = dispatch => {
    return {
        appStateAction: bindActionCreators(appStateAction, dispatch)
    };
};

export default connect(mapStateToProps, mapDispatchToProps)(ProfileFields);
